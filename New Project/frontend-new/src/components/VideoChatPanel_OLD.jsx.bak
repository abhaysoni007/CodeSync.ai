import React, { useEffect, useRef, useState, useCallback } from 'react';
import { Video, VideoOff, Mic, MicOff, Phone, Users, Send, MessageSquare } from 'lucide-react';
import toast from 'react-hot-toast';
import './VideoChatPanel.css';

/**
 * VideoChatPanel Component - Production Ready
 * Handles video calling and chat in the project room
 * 
 * FIXES IMPLEMENTED:
 * âœ… No duplicate local streams
 * âœ… Remote video properly displays
 * âœ… Camera toggle actually stops/starts video track
 * âœ… Microphone toggle actually mutes/unmutes audio track
 * âœ… Proper cleanup on disconnect
 * âœ… Permission handling
 * âœ… No duplicate peer connections
 */
const VideoChatPanel = ({
  socket,
  projectId,
  user,
  onlineUsers = [],
  messages = [],
  onSendMessage,
  newMessage,
  onMessageChange,
  typingUsers = [],
  showChat = true,
  onToggleChat,
  unreadMessages = 0
}) => {
  // Video call state
  const [isVideoOn, setIsVideoOn] = useState(false); // Start with video OFF
  const [isAudioOn, setIsAudioOn] = useState(false); // Start with audio OFF
  const [isInCall, setIsInCall] = useState(false);
  const [remoteStreams, setRemoteStreams] = useState({});
  const [incomingCall, setIncomingCall] = useState(null);

  // Refs - Use refs to avoid stale closures
  const localVideoRef = useRef(null);
  const localStreamRef = useRef(null);
  const peerConnectionsRef = useRef({});
  const pendingIceRef = useRef({});
  const messagesEndRef = useRef(null);
  const isInitializingRef = useRef(false);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    if (messagesEndRef.current && showChat) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, showChat]);

  // ==================== MEDIA STREAM MANAGEMENT ====================
  
  /**
   * Get local media stream with proper error handling
   */
  const getLocalStream = useCallback(async () => {
    if (isInitializingRef.current) {
      console.log('â³ Already initializing stream, skipping...');
      return localStreamRef.current;
    }

    if (localStreamRef.current) {
      console.log('âœ… Using existing local stream');
      return localStreamRef.current;
    }

    try {
      isInitializingRef.current = true;
      console.log('ðŸŽ¥ Requesting camera/microphone access...');
      
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: {
          width: { ideal: 1280, max: 1920 },
          height: { ideal: 720, max: 1080 },
          facingMode: 'user'
        }
      });

      console.log('âœ… Media stream obtained:', {
        id: stream.id,
        active: stream.active,
        tracks: stream.getTracks().map(t => `${t.kind}:${t.enabled}`)
      });

      localStreamRef.current = stream;

      // Set initial track states
      stream.getVideoTracks().forEach(track => {
        track.enabled = isVideoOn;
      });
      stream.getAudioTracks().forEach(track => {
        track.enabled = isAudioOn;
      });

      // Display local video
      if (localVideoRef.current) {
        localVideoRef.current.srcObject = stream;
        try {
          await localVideoRef.current.play();
          console.log('âœ… Local video element playing');
        } catch (playErr) {
          console.warn('âš ï¸ Video autoplay prevented:', playErr.message);
        }
      }

      return stream;
    } catch (err) {
      console.error('âŒ Failed to get media stream:', err);
      
      if (err.name === 'NotAllowedError') {
        toast.error('Camera/microphone access denied. Please allow permissions.');
      } else if (err.name === 'NotFoundError') {
        toast.error('No camera or microphone found.');
      } else {
        toast.error(`Media error: ${err.message}`);
      }
      
      throw err;
    } finally {
      isInitializingRef.current = false;
    }
  }, [isVideoOn, isAudioOn]);

  /**
   * Stop local media stream completely
   */
  const stopLocalStream = useCallback(() => {
    if (localStreamRef.current) {
      console.log('ðŸ›‘ Stopping local stream tracks');
      localStreamRef.current.getTracks().forEach(track => {
        track.stop();
        console.log(`  Stopped ${track.kind} track`);
      });
      localStreamRef.current = null;
    }
    
    if (localVideoRef.current) {
      localVideoRef.current.srcObject = null;
    }
  }, []);

  // ==================== PEER CONNECTION MANAGEMENT ====================

  /**
   * Create RTCPeerConnection for a remote user
   */
  const createPeerFor = useCallback(async (remoteId, isInitiator = false) => {
    // Reuse existing peer connection if available
    if (peerConnectionsRef.current[remoteId]) {
      console.log('â™»ï¸ Reusing existing peer for:', remoteId);
      return peerConnectionsRef.current[remoteId];
    }

    console.log(`ðŸ”— Creating new peer connection for: ${remoteId} (initiator: ${isInitiator})`);

    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' }
      ],
      iceCandidatePoolSize: 10
    });

    peerConnectionsRef.current[remoteId] = pc;

    // Add local tracks to peer connection
    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach(track => {
        const sender = pc.addTrack(track, localStreamRef.current);
        console.log(`  âž• Added ${track.kind} track to peer`);
      });
    } else {
      console.warn('âš ï¸ No local stream available when creating peer!');
    }

    // Handle ICE candidates
    pc.onicecandidate = (event) => {
      if (event.candidate && socket) {
        console.log(`ðŸ§Š Sending ICE candidate to ${remoteId}`);
        socket.emit('webrtc:ice-candidate', {
          to: remoteId,
          candidate: event.candidate
        });
      } else if (!event.candidate) {
        console.log(`âœ… ICE gathering complete for ${remoteId}`);
      }
    };

    // Handle incoming remote tracks
    pc.ontrack = (event) => {
      console.log(`ðŸ“¥ Received remote track from ${remoteId}:`, {
        kind: event.track.kind,
        enabled: event.track.enabled,
        muted: event.track.muted,
        readyState: event.track.readyState
      });

      if (event.streams && event.streams[0]) {
        const stream = event.streams[0];
        console.log(`  Stream ID: ${stream.id}, Active: ${stream.active}`);
        console.log(`  Tracks:`, stream.getTracks().map(t => `${t.kind}:${t.enabled}`));
        
        setRemoteStreams(prev => ({
          ...prev,
          [remoteId]: stream
        }));
        
        toast.success(`Connected to ${onlineUsers.find(u => u.id === remoteId)?.username || 'user'}`);
      }
    };

    // Connection state monitoring
    pc.onconnectionstatechange = () => {
      console.log(`ðŸ”Œ Connection state [${remoteId}]:`, pc.connectionState);
      
      if (pc.connectionState === 'connected') {
        console.log(`âœ… Peer connected: ${remoteId}`);
      } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
        console.warn(`âŒ Peer ${pc.connectionState}: ${remoteId}`);
        setTimeout(() => closePeer(remoteId), 1000);
      } else if (pc.connectionState === 'closed') {
        closePeer(remoteId);
      }
    };

    pc.oniceconnectionstatechange = () => {
      console.log(`â„ï¸ ICE connection state [${remoteId}]:`, pc.iceConnectionState);
    };

    // Process queued ICE candidates
    if (pendingIceRef.current[remoteId]) {
      console.log(`ðŸ“¦ Processing ${pendingIceRef.current[remoteId].length} queued ICE candidates`);
      for (const candidate of pendingIceRef.current[remoteId]) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (e) {
          console.warn('âš ï¸ Error adding queued ICE candidate:', e.message);
        }
      }
      delete pendingIceRef.current[remoteId];
    }

    return pc;
  }, [socket, onlineUsers]);

  /**
   * Close and cleanup peer connection
   */
  const closePeer = useCallback((id) => {
    console.log(`ðŸ—‘ï¸ Closing peer connection: ${id}`);
    
    const pc = peerConnectionsRef.current[id];
    if (pc) {
      try {
        pc.close();
      } catch (e) {
        console.error('Error closing peer:', e);
      }
      delete peerConnectionsRef.current[id];
    }

    delete pendingIceRef.current[id];
    
    setRemoteStreams(prev => {
      const updated = { ...prev };
      delete updated[id];
      return updated;
    });
  }, []);

  /**
   * Close all peer connections
   */
  const closeAllPeers = useCallback(() => {
    console.log('ðŸ—‘ï¸ Closing all peer connections');
    Object.keys(peerConnectionsRef.current).forEach(closePeer);
  }, [closePeer]);

  // Setup WebRTC event listeners
  useEffect(() => {
    if (!socket) return;

    const handleOffer = async ({ from, offer, username }) => {
      console.log('ðŸ“¨ Received offer from:', username, from);
      
      // If not in call yet, auto-accept
      if (!isInCall && !localStreamRef.current) {
        console.log('Auto-accepting call from:', username);
        setIncomingCall({
          from,
          username: username || 'Unknown User',
          offer // Store offer to process after accepting
        });
        return;
      }
      
      await handleIncomingOffer(from, offer, username);
    };

    const handleAnswer = async ({ from, answer }) => {
      console.log('ðŸ“¨ Received answer from:', from);
      const pc = peerConnectionsRef.current[from];
      if (pc && pc.signalingState !== 'stable') {
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
          console.log('âœ… Remote description set from answer');
          
          // Process queued ICE candidates
          if (pendingIceRef.current[from] && pendingIceRef.current[from].length > 0) {
            console.log('Processing queued ICE candidates after answer');
            for (const candidate of pendingIceRef.current[from]) {
              try {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
              } catch (e) {
                console.warn('Error adding queued ICE:', e);
              }
            }
            delete pendingIceRef.current[from];
          }
        } catch (err) {
          console.error('âŒ Error setting remote description:', err);
        }
      }
    };

    const handleIceCandidate = async ({ from, candidate }) => {
      console.log('Received ICE candidate from:', from);
      const pc = peerConnectionsRef.current[from];
      if (pc && pc.remoteDescription) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
          console.warn('Error adding ICE candidate:', err);
        }
      } else {
        // Queue ICE candidates if remote description not set yet
        if (!pendingIceRef.current[from]) {
          pendingIceRef.current[from] = [];
        }
        pendingIceRef.current[from].push(candidate);
      }
    };

    const handleCallStarted = ({ from, username }) => {
      console.log('Call started by:', username || from);
      
      // Show incoming call notification only if not already in call
      if (!isInCall) {
        setIncomingCall({
          from,
          username: username || 'Unknown User'
        });
        toast(`${username} is calling...`, {
          duration: 10000,
          icon: 'ðŸ“ž',
        });
      }
    };

    const handleCallEnded = ({ userId, username }) => {
      console.log('Call ended by:', username || userId);
      toast(`${username} left the call`);
      closePeer(userId);
    };

    socket.on('webrtc:offer', handleOffer);
    socket.on('webrtc:answer', handleAnswer);
    socket.on('webrtc:ice-candidate', handleIceCandidate);
    socket.on('webrtc:call-started', handleCallStarted);
    socket.on('webrtc:call-ended', handleCallEnded);

    return () => {
      socket.off('webrtc:offer', handleOffer);
      socket.off('webrtc:answer', handleAnswer);
      socket.off('webrtc:ice-candidate', handleIceCandidate);
      socket.off('webrtc:call-started', handleCallStarted);
      socket.off('webrtc:call-ended', handleCallEnded);
    };
  }, [socket, projectId]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      stopLocalStream();
      Object.keys(peerConnectionsRef.current).forEach(closePeer);
    };
  }, []);

  const stopLocalStream = () => {
    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach(t => t.stop());
      localStreamRef.current = null;
    }
    if (localVideoRef.current) {
      localVideoRef.current.srcObject = null;
    }
  };

  const createPeerFor = async (remoteId, isInitiator = false) => {
    if (peerConnectionsRef.current[remoteId]) {
      console.log('Reusing existing peer connection for:', remoteId);
      return peerConnectionsRef.current[remoteId];
    }

    console.log('Creating peer connection for:', remoteId, 'isInitiator:', isInitiator);

    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    });

    peerConnectionsRef.current[remoteId] = pc;

    // Add local tracks FIRST before setting up event handlers
    if (localStreamRef.current) {
      const tracks = localStreamRef.current.getTracks();
      console.log('Adding local tracks to peer:', tracks.map(t => `${t.kind}:${t.enabled}`));
      
      tracks.forEach(track => {
        const sender = pc.addTrack(track, localStreamRef.current);
        console.log('Track added:', track.kind, 'sender:', sender);
      });
    } else {
      console.warn('No local stream available when creating peer connection!');
    }

    // Handle ICE candidates
    pc.onicecandidate = (ev) => {
      if (ev.candidate && socket) {
        console.log('Sending ICE candidate to:', remoteId);
        socket.emit('webrtc:ice-candidate', {
          to: remoteId,
          candidate: ev.candidate
        });
      } else if (!ev.candidate) {
        console.log('ICE gathering complete for:', remoteId);
      }
    };

    // Handle incoming tracks
    pc.ontrack = (ev) => {
      console.log('ðŸŽ¥ Received remote track from:', remoteId);
      console.log('Track details:', {
        kind: ev.track.kind,
        enabled: ev.track.enabled,
        muted: ev.track.muted,
        readyState: ev.track.readyState
      });
      console.log('Streams:', ev.streams?.length, ev.streams);
      
      const stream = ev.streams && ev.streams[0];
      if (stream) {
        console.log('Setting remote stream:', stream.id, 'active:', stream.active);
        console.log('Stream tracks:', stream.getTracks().map(t => `${t.kind}:${t.enabled}`));
        setRemoteStream(remoteId, stream);
      } else {
        console.warn('No stream in track event!');
      }
    };

    // Handle connection state changes
    pc.onconnectionstatechange = () => {
      console.log('Connection state for', remoteId, ':', pc.connectionState);
      if (pc.connectionState === 'connected') {
        console.log('âœ… Peer connection established with:', remoteId);
      } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
        console.warn('âŒ Connection failed/disconnected for:', remoteId);
        closePeer(remoteId);
      }
    };

    // Handle ICE connection state
    pc.oniceconnectionstatechange = () => {
      console.log('ICE connection state for', remoteId, ':', pc.iceConnectionState);
    };

    // Process any queued ICE candidates
    if (pendingIceRef.current[remoteId]) {
      console.log('Processing', pendingIceRef.current[remoteId].length, 'queued ICE candidates');
      for (const cand of pendingIceRef.current[remoteId]) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(cand));
        } catch (e) {
          console.warn('Error adding queued ICE candidate:', e);
        }
      }
      delete pendingIceRef.current[remoteId];
    }

    return pc;
  };

  const setRemoteStream = (id, stream) => {
    console.log('Setting remote stream for:', id);
    setRemoteStreams(prev => ({
      ...prev,
      [id]: stream
    }));
  };

  const closePeer = (id) => {
    console.log('Closing peer connection for:', id);
    const pc = peerConnectionsRef.current[id];
    if (pc) {
      try {
        pc.close();
      } catch (e) {
        console.error('Error closing peer connection:', e);
      }
      delete peerConnectionsRef.current[id];
    }
    delete pendingIceRef.current[id];
    setRemoteStreams(prev => {
      const updated = { ...prev };
      delete updated[id];
      return updated;
    });
  };

  const handleIncomingOffer = async (from, offer, username) => {
    try {
      console.log('ðŸ“¨ Handling incoming offer from:', username, from);
      
      // Start local stream if not already started
      if (!localStreamRef.current) {
        console.log('Getting local stream before handling offer...');
        await getLocalStream();
        // Wait a bit for stream to be fully ready
        await new Promise(resolve => setTimeout(resolve, 500));
      }

      const pc = await createPeerFor(from, false);
      
      console.log('Setting remote description...');
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      console.log('âœ… Remote description set for incoming offer');
      
      console.log('Creating answer...');
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      console.log('âœ… Created and set local answer');

      if (socket) {
        socket.emit('webrtc:answer', { to: from, answer });
        console.log('ðŸ“¤ Sent answer to:', from);
      }

      setIsInCall(true);
      toast.success(`${username} joined the call`);
    } catch (err) {
      console.error('âŒ Error handling incoming offer:', err);
      toast.error('Failed to join call');
    }
  };

  const getLocalStream = async () => {
    try {
      console.log('Getting local media stream with video:', isVideoOn, 'audio:', isAudioOn);
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: { 
          width: { ideal: 640 },
          height: { ideal: 480 },
          facingMode: 'user'
        }
      });

      localStreamRef.current = stream;
      
      // Set srcObject and play video
      if (localVideoRef.current) {
        localVideoRef.current.srcObject = stream;
        // Ensure video plays
        try {
          await localVideoRef.current.play();
          console.log('Local video playing');
        } catch (playErr) {
          console.warn('Video play failed (might autoplay):', playErr);
        }
      }

      // Set initial video track state based on isVideoOn
      const videoTrack = stream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = isVideoOn;
        console.log('Video track enabled:', videoTrack.enabled, 'readyState:', videoTrack.readyState);
      }

      // Set initial audio track state based on isAudioOn
      const audioTrack = stream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = isAudioOn;
        console.log('Audio track enabled:', audioTrack.enabled, 'readyState:', audioTrack.readyState);
      }

      console.log('Local stream obtained:', stream.getTracks().map(t => `${t.kind}:${t.enabled}`));
      console.log('Stream active:', stream.active, 'id:', stream.id);
      return stream;
    } catch (err) {
      console.error('Error getting local stream:', err);
      toast.error('Failed to access camera/microphone. Please allow permissions.');
      throw err;
    }
  };

  const startCall = async () => {
    try {
      console.log('ðŸŽ¬ Starting call...');
      
      // Get local stream first
      const stream = await getLocalStream();
      console.log('âœ… Local stream ready:', stream.id);
      
      // Wait a bit for stream to be fully initialized
      await new Promise(resolve => setTimeout(resolve, 500));
      
      setIsInCall(true);

      // Notify others that call started
      if (socket) {
        socket.emit('webrtc:call-started', { projectId });
        console.log('ðŸ“¢ Notified others about call start');
      }

      // Create offers for all online users except self
      const otherUsers = onlineUsers.filter(u => u.id !== user?.id);
      console.log('ðŸ‘¥ Creating offers for users:', otherUsers.map(u => u.username));

      for (const onlineUser of otherUsers) {
        try {
          console.log('Creating peer for:', onlineUser.username);
          const pc = await createPeerFor(onlineUser.id, true);
          
          console.log('Creating offer for:', onlineUser.username);
          const offer = await pc.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          });
          
          await pc.setLocalDescription(offer);
          console.log('âœ… Local description set for:', onlineUser.username);
          
          socket.emit('webrtc:offer', {
            to: onlineUser.id,
            offer: offer
          });
          console.log('ðŸ“¤ Sent offer to:', onlineUser.username, onlineUser.id);
        } catch (err) {
          console.error('âŒ Error creating offer for user:', onlineUser.username, err);
        }
      }

      toast.success('Call started');
    } catch (err) {
      console.error('âŒ Error starting call:', err);
      setIsInCall(false);
      toast.error('Failed to start call');
    }
  };

  const endCall = () => {
    console.log('Ending call...');
    
    // Notify others
    if (socket) {
      socket.emit('webrtc:end-call', {
        projectId,
        userId: user?.id,
        username: user?.username
      });
    }

    // Close all peer connections
    Object.keys(peerConnectionsRef.current).forEach(closePeer);
    
    // Stop local stream
    stopLocalStream();
    
    setIsInCall(false);
    setRemoteStreams({});
    setIncomingCall(null); // Clear incoming call notification
    toast.success('Call ended');
  };

  const acceptCall = async () => {
    try {
      console.log('âœ… Accepting call from:', incomingCall?.username);
      
      // Get local stream first
      if (!localStreamRef.current) {
        await getLocalStream();
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      setIsInCall(true);
      
      // If there's a stored offer, process it
      if (incomingCall?.offer) {
        await handleIncomingOffer(incomingCall.from, incomingCall.offer, incomingCall.username);
      }
      
      // Notify others that we joined the call
      if (socket) {
        socket.emit('webrtc:call-started', { projectId });
      }
      
      // Send offers to all online users who are already in call
      const otherUsers = onlineUsers.filter(u => u.id !== user?.id);
      for (const onlineUser of otherUsers) {
        // Skip if we already have a peer connection (from incoming offer)
        if (!peerConnectionsRef.current[onlineUser.id]) {
          try {
            const pc = await createPeerFor(onlineUser.id, true);
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            await pc.setLocalDescription(offer);
            
            socket.emit('webrtc:offer', {
              to: onlineUser.id,
              offer: offer
            });
            console.log('ðŸ“¤ Sent offer to:', onlineUser.username);
          } catch (err) {
            console.error('Error creating offer:', err);
          }
        }
      }
      
      setIncomingCall(null);
      toast.success('Joined the call');
    } catch (err) {
      console.error('âŒ Error accepting call:', err);
      toast.error('Failed to join call');
    }
  };

  const declineCall = () => {
    console.log('Declining call from:', incomingCall?.username);
    setIncomingCall(null);
    toast('Call declined', { icon: 'ðŸ“µ' });
  };

  const toggleVideo = async () => {
    if (localStreamRef.current) {
      const videoTrack = localStreamRef.current.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        setIsVideoOn(videoTrack.enabled);
        console.log('Video toggled:', videoTrack.enabled);
        toast(videoTrack.enabled ? 'Camera turned on' : 'Camera turned off', {
          icon: videoTrack.enabled ? 'ðŸ“¹' : 'ðŸ“·',
          duration: 2000
        });
      }
    } else if (!isInCall) {
      // Toggle preference before starting call
      setIsVideoOn(!isVideoOn);
    }
  };

  const toggleAudio = () => {
    if (localStreamRef.current) {
      const audioTrack = localStreamRef.current.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        setIsAudioOn(audioTrack.enabled);
        console.log('Audio toggled:', audioTrack.enabled);
        toast(audioTrack.enabled ? 'Microphone unmuted' : 'Microphone muted', {
          icon: audioTrack.enabled ? 'ðŸŽ¤' : 'ðŸ”‡',
          duration: 2000
        });
      }
    } else if (!isInCall) {
      // Toggle preference before starting call
      setIsAudioOn(!isAudioOn);
    }
  };

  const generateUserColor = (userId) => {
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A',
      '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
      '#F8B739', '#52C41A', '#1890FF', '#722ED1'
    ];

    if (!userId) return colors[0];

    const hash = userId.split('').reduce((acc, char) => {
      return char.charCodeAt(0) + ((acc << 5) - acc);
    }, 0);

    return colors[Math.abs(hash) % colors.length];
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (onSendMessage) {
      onSendMessage(e);
    }
  };

  return (
    <aside className="w-80 bg-vscode-panel border-l border-vscode-border flex flex-col video-chat-panel">
      {/* Tabs */}
      <div className="video-chat-tabs">
        <button
          onClick={() => onToggleChat && onToggleChat(true)}
          className={`tab ${showChat ? 'active' : ''}`}
        >
          <MessageSquare className="w-4 h-4" />
          Chat
          {unreadMessages > 0 && !showChat && (
            <span className="unread-badge">
              {unreadMessages > 9 ? '9+' : unreadMessages}
            </span>
          )}
        </button>
        <button
          onClick={() => onToggleChat && onToggleChat(false)}
          className={`tab ${!showChat ? 'active' : ''}`}
        >
          <Video className="w-4 h-4" />
          Video
        </button>
      </div>

      {/* Chat Panel */}
      {showChat && (
        <div className="chat-container">
          {/* Messages */}
          <div className="messages-list">
            {messages.length === 0 ? (
              <div className="empty-state">
                <MessageSquare className="empty-icon" />
                <p>No messages yet</p>
                <p className="empty-subtitle">Start the conversation!</p>
              </div>
            ) : (
              messages.map((msg, idx) => {
                const isOwnMessage = msg.userId === user?.id;
                const messageTime = new Date(msg.timestamp || msg.createdAt);
                const isToday = messageTime.toDateString() === new Date().toDateString();
                const timeString = isToday
                  ? messageTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                  : messageTime.toLocaleString([], {
                      month: 'short',
                      day: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit'
                    });

                return (
                  <div key={idx} className={`message ${isOwnMessage ? 'own' : 'other'}`}>
                    <div className="message-header">
                      {!isOwnMessage && (
                        <>
                          <div
                            className="avatar"
                            style={{ backgroundColor: generateUserColor(msg.userId || 'default') }}
                          >
                            {msg.username?.[0]?.toUpperCase() || 'U'}
                          </div>
                          <span className="username">{msg.username}</span>
                        </>
                      )}
                      {isOwnMessage && <span className="username">You</span>}
                      <span className="timestamp" title={messageTime.toLocaleString()}>
                        {timeString}
                      </span>
                    </div>
                    <div className={`message-bubble ${isOwnMessage ? 'own' : 'other'}`}>
                      <p>{msg.message || msg.content}</p>
                    </div>
                  </div>
                );
              })
            )}

            {/* Typing Indicator */}
            {typingUsers.length > 0 && (
              <div className="typing-indicator">
                {typingUsers.length === 1
                  ? `${typingUsers[0].username} is typing...`
                  : typingUsers.length === 2
                  ? `${typingUsers[0].username} and ${typingUsers[1].username} are typing...`
                  : `${typingUsers.length} people are typing...`}
              </div>
            )}

            <div ref={messagesEndRef} />
          </div>

          {/* Message Input */}
          <form onSubmit={handleSubmit} className="message-input">
            <input
              type="text"
              value={newMessage}
              onChange={(e) => onMessageChange && onMessageChange(e)}
              placeholder="Type a message..."
              className="input-field"
            />
            <button
              type="submit"
              className="send-button"
              disabled={!newMessage?.trim()}
            >
              <Send className="w-4 h-4" />
            </button>
          </form>
        </div>
      )}

      {/* Video Panel */}
      {!showChat && (
        <div className="video-container">
          {/* Incoming Call Notification */}
          {incomingCall && !isInCall && (
            <div className="incoming-call-notification">
              <div className="incoming-call-content">
                <Video className="incoming-call-icon" />
                <h3>{incomingCall.username} is calling...</h3>
                <p>Video Call</p>
                <div className="incoming-call-actions">
                  <button onClick={acceptCall} className="accept-call-button">
                    <Phone className="w-5 h-5" />
                    Accept
                  </button>
                  <button onClick={declineCall} className="decline-call-button">
                    <Phone className="w-5 h-5 rotate-135" />
                    Decline
                  </button>
                </div>
              </div>
            </div>
          )}

          {!isInCall ? (
            <div className="video-empty-state">
              <Video className="video-icon" />
              <h3>Video Call</h3>
              <p>Start a video call with your team</p>
              <button onClick={startCall} className="start-call-button">
                <Video className="w-4 h-4" />
                Start Call
              </button>
            </div>
          ) : (
            <>
              <div className="video-grid">
                {/* Remote Videos - Show FIRST */}
                {Object.entries(remoteStreams).map(([userId, stream]) => {
                  const remoteUser = onlineUsers.find(u => u.id === userId);
                  const hasVideoTrack = stream.getVideoTracks().length > 0;
                  const isVideoEnabled = hasVideoTrack && stream.getVideoTracks()[0].enabled;
                  
                  return (
                    <div key={userId} className="video-wrapper remote">
                      <video
                        ref={el => {
                          if (el && stream && el.srcObject !== stream) {
                            console.log(`ðŸŽ¥ Setting stream for remote user: ${remoteUser?.username}`, stream);
                            console.log(`Video tracks: ${stream.getVideoTracks().length}, Audio tracks: ${stream.getAudioTracks().length}`);
                            stream.getVideoTracks().forEach(track => {
                              console.log(`Video track state: ${track.readyState}, enabled: ${track.enabled}`);
                            });
                            el.srcObject = stream;
                            el.play().catch(err => console.error('Error playing remote video:', err));
                          }
                        }}
                        autoPlay
                        playsInline
                        className="video-element"
                      />
                      <div className="video-label">
                        {remoteUser?.username || 'Unknown User'}
                        {!isVideoEnabled && ' (Camera Off)'}
                      </div>
                      {!isVideoEnabled && (
                        <div className="video-placeholder">
                          <div className="avatar-large" style={{ backgroundColor: generateUserColor(userId) }}>
                            {remoteUser?.username?.[0]?.toUpperCase() || 'U'}
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })}

                {/* Local Video - Show LAST */}
                <div className="video-wrapper local">
                  <video
                    ref={localVideoRef}
                    autoPlay
                    muted
                    playsInline
                    className="video-element"
                  />
                  <div className="video-label">
                    You {!isVideoOn && '(Camera Off)'}
                  </div>
                  {!isVideoOn && (
                    <div className="video-placeholder">
                      <div className="avatar-large" style={{ backgroundColor: generateUserColor(user?.id) }}>
                        {user?.username?.[0]?.toUpperCase()}
                      </div>
                    </div>
                  )}
                </div>

                {/* No other participants */}
                {Object.keys(remoteStreams).length === 0 && (
                  <div className="waiting-state">
                    <Users className="waiting-icon" />
                    <p>Waiting for others to join...</p>
                  </div>
                )}
              </div>

              {/* Video Controls */}
              <div className="video-controls">
                <button
                  onClick={toggleVideo}
                  className={`control-button ${!isVideoOn ? 'off' : ''}`}
                  title={isVideoOn ? 'Turn off camera' : 'Turn on camera'}
                >
                  {isVideoOn ? (
                    <Video className="w-5 h-5" />
                  ) : (
                    <VideoOff className="w-5 h-5" />
                  )}
                </button>

                <button
                  onClick={toggleAudio}
                  className={`control-button ${!isAudioOn ? 'off' : ''}`}
                  title={isAudioOn ? 'Mute microphone' : 'Unmute microphone'}
                >
                  {isAudioOn ? (
                    <Mic className="w-5 h-5" />
                  ) : (
                    <MicOff className="w-5 h-5" />
                  )}
                </button>

                <button
                  onClick={endCall}
                  className="control-button end-call"
                  title="End call"
                >
                  <Phone className="w-5 h-5 rotate-135" />
                </button>
              </div>
            </>
          )}
        </div>
      )}

      {/* Online Users List */}
      <div className="online-users">
        <h3 className="users-header">
          Online Users ({onlineUsers.length})
        </h3>
        <div className="users-list">
          {onlineUsers.map((u, index) => (
            <div key={`${u.id}-${u.username}-${index}`} className="user-item">
              <div className="online-indicator"></div>
              <span className="user-name">{u.username}</span>
            </div>
          ))}
        </div>
      </div>
    </aside>
  );
};

export default VideoChatPanel;

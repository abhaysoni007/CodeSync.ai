import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import UserAPIKey from '../models/UserAPIKey.js';
import encryptionHelper from '../utils/encryption.js';
import AgentService from '../services/AgentService.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Project root for frontend
const FRONTEND_ROOT = path.join(__dirname, '../../frontend-new/src');
const AUTO_GENERATED_DIR = path.join(FRONTEND_ROOT, 'auto_generated');
const AGENT_LOG_FILE = path.join(__dirname, '../agent_logs.json');

// Ensure directories exist
async function ensureDirectories() {
  try {
    await fs.mkdir(AUTO_GENERATED_DIR, { recursive: true });
    await fs.mkdir(path.join(AUTO_GENERATED_DIR, 'components'), { recursive: true });
    await fs.mkdir(path.join(AUTO_GENERATED_DIR, 'pages'), { recursive: true });
  } catch (error) {
    console.error('Error creating directories:', error);
  }
}

// Initialize
ensureDirectories();

// Log agent activity
async function logActivity(activity) {
  try {
    let logs = [];
    try {
      const data = await fs.readFile(AGENT_LOG_FILE, 'utf8');
      logs = JSON.parse(data);
    } catch (error) {
      // File doesn't exist yet
    }

    logs.push({
      ...activity,
      timestamp: new Date().toISOString()
    });

    // Keep only last 100 logs
    if (logs.length > 100) {
      logs = logs.slice(-100);
    }

    await fs.writeFile(AGENT_LOG_FILE, JSON.stringify(logs, null, 2));
  } catch (error) {
    console.error('Error logging activity:', error);
  }
}

// Call AI to generate code
async function generateCode(prompt, type = 'component') {
  try {
    // Use free AI provider (you can switch to OpenAI/Claude if configured)
    const systemPrompt = type === 'component'
      ? `You are a React component generator. Generate clean, modern React components using Tailwind CSS and React hooks. 
         Follow best practices:
         - Use functional components with hooks
         - Include PropTypes
         - Use Tailwind CSS for styling
         - Add proper imports
         - Make components reusable
         - Return ONLY the code, no explanations`
      : `You are a React page generator. Generate complete page components using Tailwind CSS.
         Follow best practices:
         - Use functional components
         - Include proper imports
         - Use Tailwind CSS for styling
         - Make responsive designs
         - Return ONLY the code, no explanations`;

    // Simple template-based generation (fallback if no AI API)
    const code = generateTemplateCode(prompt, type);
    return code;

  } catch (error) {
    console.error('Code generation error:', error);
    throw new Error('Failed to generate code');
  }
}

// Template-based code generation (fallback)
function generateTemplateCode(prompt, type) {
  const componentName = extractComponentName(prompt);
  
  if (type === 'component') {
    return `import { useState } from 'react';
import PropTypes from 'prop-types';

const ${componentName} = ({ title, onAction }) => {
  const [state, setState] = useState(null);

  const handleClick = () => {
    if (onAction) {
      onAction();
    }
  };

  return (
    <div className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg">
      <h2 className="text-2xl font-bold text-gray-900 dark:text-white mb-4">
        {title || '${componentName}'}
      </h2>
      <div className="space-y-4">
        <p className="text-gray-600 dark:text-gray-300">
          Component generated by AI Agent
        </p>
        <button
          onClick={handleClick}
          className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
        >
          Click Me
        </button>
      </div>
    </div>
  );
};

${componentName}.propTypes = {
  title: PropTypes.string,
  onAction: PropTypes.func
};

export default ${componentName};
`;
  } else {
    return `import { useState, useEffect } from 'react';

const ${componentName} = () => {
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // Initialize page
    console.log('${componentName} mounted');
  }, []);

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      <div className="container mx-auto px-4 py-8">
        <header className="mb-8">
          <h1 className="text-4xl font-bold text-gray-900 dark:text-white">
            ${componentName}
          </h1>
          <p className="text-gray-600 dark:text-gray-400 mt-2">
            Page generated by AI Agent
          </p>
        </header>

        <main className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
          <div className="space-y-6">
            <section>
              <h2 className="text-2xl font-semibold text-gray-800 dark:text-gray-200 mb-4">
                Welcome
              </h2>
              <p className="text-gray-600 dark:text-gray-300">
                This is your ${componentName} page. Start customizing it!
              </p>
            </section>

            <section className="pt-6 border-t border-gray-200 dark:border-gray-700">
              <button
                onClick={() => setLoading(!loading)}
                className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
              >
                {loading ? 'Loading...' : 'Get Started'}
              </button>
            </section>
          </div>
        </main>
      </div>
    </div>
  );
};

export default ${componentName};
`;
  }
}

// Extract component name from prompt
function extractComponentName(prompt) {
  const words = prompt.toLowerCase().split(' ');
  
  // Look for common patterns
  const patterns = [
    /create (?:a |an )?(\w+)/i,
    /generate (?:a |an )?(\w+)/i,
    /make (?:a |an )?(\w+)/i,
    /(\w+) component/i,
    /(\w+) page/i
  ];

  for (const pattern of patterns) {
    const match = prompt.match(pattern);
    if (match && match[1]) {
      return capitalizeFirst(match[1]);
    }
  }

  // Default fallback
  const firstWord = words.find(w => w.length > 3) || 'Generated';
  return capitalizeFirst(firstWord) + 'Component';
}

function capitalizeFirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Main agent request handler - AI-powered autonomous agent
 */
export const handleAgentRequest = async (req, res) => {
  try {
    const { command, projectRoot, model = 'gemini-2.0-flash-exp' } = req.body;
    const userId = req.userId;

    if (!command) {
      return res.status(400).json({
        success: false,
        message: 'Command is required'
      });
    }

    console.log('ü§ñ Agent Task Request:', {
      userId,
      command: command.substring(0, 100),
      model
    });

    // Set default project root to frontend-new/src/auto_generated
    const FRONTEND_ROOT = path.join(__dirname, '../../frontend-new/src/auto_generated');
    const absoluteProjectRoot = projectRoot ? path.resolve(projectRoot) : FRONTEND_ROOT;

    console.log('üìÇ Project root:', absoluteProjectRoot);

    // Get user's Gemini API key
    const userApiKey = await UserAPIKey.findOne({
      userId: userId,
      provider: 'google',
      isActive: true
    });

    if (!userApiKey) {
      return res.status(400).json({
        success: false,
        message: 'Gemini API key not configured. Please add your API key in Profile settings.',
        requiresApiKey: true,
        logs: [{
          type: 'error',
          message: '‚ùå No API key found. Go to Profile ‚Üí API Keys to add your Gemini key.'
        }]
      });
    }

    // Decrypt API key
    let geminiApiKey;
    try {
      geminiApiKey = encryptionHelper.decryptAPIKey(
        userApiKey.encryptedKey,
        userApiKey.iv,
        userApiKey.authTag
      );
    } catch (error) {
      console.error('Decryption error:', error);
      return res.status(500).json({
        success: false,
        message: 'Failed to decrypt API key. Please re-save your API key in Profile settings.',
        logs: [{
          type: 'error',
          message: '‚ùå API key decryption failed. Re-save your key in Profile.'
        }]
      });
    }

    // Execute agent task
    const result = await AgentService.executeTask(
      geminiApiKey,
      command,
      absoluteProjectRoot,
      model
    );

    // Update last used timestamp
    await UserAPIKey.findByIdAndUpdate(userApiKey._id, {
      lastUsed: new Date()
    });

    // Log activity
    await logActivity({
      userId: userId,
      command,
      success: true,
      filesCreated: result.filesCreated,
      filesModified: result.filesModified,
      filesDeleted: result.filesDeleted
    });

    console.log('‚úÖ Agent task completed:', {
      filesCreated: result.filesCreated.length,
      filesModified: result.filesModified.length,
      filesDeleted: result.filesDeleted.length,
      pendingPermissions: result.pendingPermissions.length
    });

    res.json({
      success: true,
      message: result.summary,
      filesCreated: result.filesCreated,
      filesModified: result.filesModified,
      filesDeleted: result.filesDeleted,
      pendingPermissions: result.pendingPermissions,
      details: {
        taskUnderstanding: result.taskUnderstanding
      },
      logs: result.logs
    });

  } catch (error) {
    console.error('‚ùå Agent execution error:', error);
    
    await logActivity({
      userId: req.userId,
      command: req.body.command,
      success: false,
      error: error.message
    });

    res.status(500).json({
      success: false,
      message: error.message || 'Agent task failed',
      logs: AgentService.logs
    });
  }
};

async function handleComponentRequest(command, logs) {
  const componentName = extractComponentName(command);
  const fileName = `${componentName}.jsx`;
  const filePath = path.join(AUTO_GENERATED_DIR, 'components', fileName);

  logs.push({
    type: 'info',
    message: `üìù Generating component: ${componentName}`
  });

  // Generate code
  const code = await generateCode(command, 'component');

  logs.push({
    type: 'terminal',
    message: `Writing file: ${fileName}`
  });

  // Write file
  await fs.writeFile(filePath, code, 'utf8');

  logs.push({
    type: 'success',
    message: `‚úÖ Created ${fileName} successfully!`
  });

  return {
    message: `‚úÖ Component "${componentName}" created successfully!`,
    filesCreated: [fileName],
    filesModified: [],
    details: {
      path: filePath,
      name: componentName,
      type: 'component'
    }
  };
}

async function handlePageRequest(command, logs) {
  const pageName = extractComponentName(command);
  const fileName = `${pageName}.jsx`;
  const filePath = path.join(AUTO_GENERATED_DIR, 'pages', fileName);

  logs.push({
    type: 'info',
    message: `üìù Generating page: ${pageName}`
  });

  // Generate code
  const code = await generateCode(command, 'page');

  logs.push({
    type: 'terminal',
    message: `Writing file: ${fileName}`
  });

  // Write file
  await fs.writeFile(filePath, code, 'utf8');

  logs.push({
    type: 'success',
    message: `‚úÖ Created ${fileName} successfully!`
  });

  return {
    message: `‚úÖ Page "${pageName}" created successfully!`,
    filesCreated: [fileName],
    filesModified: [],
    details: {
      path: filePath,
      name: pageName,
      type: 'page'
    }
  };
}

async function handleModifyRequest(command, logs) {
  logs.push({
    type: 'warning',
    message: '‚ö†Ô∏è  File modification requires specific file path'
  });

  return {
    message: '‚ö†Ô∏è  File modification feature - please specify the file path',
    filesCreated: [],
    filesModified: [],
    details: {
      note: 'Modification requires file path parameter'
    }
  };
}

export const createComponent = async (req, res) => {
  try {
    const { name, type = 'functional' } = req.body;
    // Implementation
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};

export const createPage = async (req, res) => {
  try {
    const { name, route } = req.body;
    // Implementation
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};

export const modifyFile = async (req, res) => {
  try {
    const { filePath, changes } = req.body;
    // Implementation
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};

export const getAgentLogs = async (req, res) => {
  try {
    const data = await fs.readFile(AGENT_LOG_FILE, 'utf8');
    const logs = JSON.parse(data);
    
    // Filter by user if needed
    const userLogs = logs.filter(log => log.userId === req.userId);
    
    res.json({
      success: true,
      data: userLogs
    });
  } catch (error) {
    res.json({
      success: true,
      data: []
    });
  }
};

/**
 * Execute approved permission action (terminal commands)
 */
export const executeApprovedAction = async (req, res) => {
  try {
    const { action, projectRoot = './projects' } = req.body;

    if (!action || !action.action || action.action !== 'RUN_COMMAND') {
      return res.status(400).json({
        success: false,
        message: 'Invalid action. Only RUN_COMMAND is supported.'
      });
    }

    console.log('üîì User approved command:', action.target);

    // Resolve absolute project root
    const absoluteProjectRoot = path.resolve(projectRoot);

    // Execute the approved action
    const result = await AgentService.executePermissionAction(action, absoluteProjectRoot);

    console.log('‚úÖ Approved action executed');

    res.json({
      success: true,
      message: 'Command executed successfully',
      result: result.result,
      logs: result.logs
    });

  } catch (error) {
    console.error('‚ùå Approved action error:', error);
    res.status(500).json({
      success: false,
      message: 'Command execution failed',
      error: error.message
    });
  }
};
